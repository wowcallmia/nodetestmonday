'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.default = markdownToJSX;

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _unified = require('unified');

var _unified2 = _interopRequireDefault(_unified);

var _remarkParse = require('remark-parse');

var _remarkParse2 = _interopRequireDefault(_remarkParse);

var _lodash = require('lodash.get');

var _lodash2 = _interopRequireDefault(_lodash);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var getType = Object.prototype.toString;
var textTypes = ['text', 'textNode'];

function markdownToJSX(markdown) {
    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
    var overrides = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

    var definitions = void 0;
    var footnotes = void 0;

    function getHTMLNodeTypeFromASTNodeType(node) {
        switch (node.type) {
            case 'break':
                return 'br';

            case 'delete':
                return 'del';

            case 'emphasis':
                return 'em';

            case 'footnoteReference':
                return 'a';

            case 'heading':
                return 'h' + node.depth;

            case 'html':
                return 'div';

            case 'image':
            case 'imageReference':
                return 'img';

            case 'inlineCode':
                return 'code';

            case 'link':
            case 'linkReference':
                return 'a';

            case 'list':
                return node.ordered ? 'ol' : 'ul';

            case 'listItem':
                return 'li';

            case 'paragraph':
                return 'p';

            case 'root':
                return 'div';

            case 'tableHeader':
                return 'thead';

            case 'tableRow':
                return 'tr';

            case 'tableCell':
                return 'td';

            case 'thematicBreak':
                return 'hr';

            case 'definition':
            case 'footnoteDefinition':
            case 'yaml':
                return null;

            default:
                return node.type;
        }
    }

    function formExtraPropsForHTMLNodeType() {
        var props = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
        var ast = arguments[1];

        switch (ast.type) {
            case 'footnoteReference':
                return _extends({}, props, {
                    href: '#' + ast.identifier
                });

            case 'image':
                return _extends({}, props, {
                    title: ast.title,
                    alt: ast.alt,
                    src: ast.url
                });

            case 'imageReference':
                return _extends({}, props, {
                    title: (0, _lodash2.default)(definitions, '[\'' + ast.identifier + '\'].title'),
                    alt: ast.alt,
                    src: (0, _lodash2.default)(definitions, '[\'' + ast.identifier + '\'].url')
                });

            case 'link':
                return _extends({}, props, {
                    title: ast.title,
                    href: ast.url
                });

            case 'linkReference':
                return _extends({}, props, {
                    title: (0, _lodash2.default)(definitions, '[\'' + ast.identifier + '\'].title'),
                    href: (0, _lodash2.default)(definitions, '[\'' + ast.identifier + '\'].url')
                });

            case 'list':
                return _extends({}, props, {
                    start: ast.start
                });

            case 'tableCell':
            case 'th':
                return _extends({}, props, {
                    style: { textAlign: ast.align }
                });
        }

        return props;
    }

    function seekCellsAndAlignThemIfNecessary(root, alignmentValues) {
        var mapper = function mapper(child, index) {
            if (child.type === 'tableCell') {
                return _extends({}, child, {
                    align: alignmentValues[index]
                });
            } else if (Array.isArray(child.children) && child.children.length) {
                return child.children.map(mapper);
            }

            return child;
        };

        if (Array.isArray(root.children) && root.children.length) {
            root.children = root.children.map(mapper);
        }

        return root;
    }

    function astToJSX(ast, index) {
        /* `this` is the dictionary of definitions */
        if (textTypes.indexOf(ast.type) !== -1) {
            return ast.value;
        }

        var key = index || '0';

        if (ast.type === 'code') {
            return _react2.default.createElement(
                'pre',
                { key: key },
                _react2.default.createElement(
                    'code',
                    { className: 'lang-' + ast.lang },
                    ast.value
                )
            );
        } /* Refers to fenced blocks, need to create a pre:code nested structure */

        if (ast.type === 'list' && ast.loose === false) {
            ast.children = ast.children.map(function (item) {
                if (item.children.length === 1 && item.children[0].type === 'paragraph') {
                    return _extends({}, item, {
                        children: item.children[0].children
                    });
                }

                return item;
            });
        } /* tight list, remove the paragraph wrapper just inside the listItem */

        if (ast.type === 'listItem') {
            if (ast.checked === true || ast.checked === false) {
                return _react2.default.createElement(
                    'li',
                    { key: key },
                    _react2.default.createElement('input', { key: 'checkbox',
                        type: 'checkbox',
                        checked: ast.checked,
                        disabled: true }),
                    ast.children.map(astToJSX)
                );
            } /* gfm task list, need to add a checkbox */
        }

        if (ast.type === 'html') {
            return _react2.default.createElement('div', { key: key, dangerouslySetInnerHTML: { __html: ast.value } });
        } /* arbitrary HTML, do the gross thing for now */

        if (ast.type === 'table') {
            (function () {
                var tbody = { type: 'tbody', children: [] };

                ast.children = ast.children.reduce(function (children, child, index) {
                    if (index === 0) {
                        /* manually marking the first row as tableHeader since that was removed in remark@4.x; it's important semantically. */
                        child.type = 'tableHeader';
                        children.unshift(seekCellsAndAlignThemIfNecessary(child, ast.align));
                    } else if (child.type === 'tableRow') {
                        tbody.children.push(seekCellsAndAlignThemIfNecessary(child, ast.align));
                    } else if (child.type === 'tableFooter') {
                        children.push(seekCellsAndAlignThemIfNecessary(child, ast.align));
                    }

                    return children;
                }, [tbody]);
            })();
        } /* React yells if things aren't in the proper structure, so need to
            delve into the immediate children and wrap tablerow(s) in a tbody */

        if (ast.type === 'tableFooter') {
            ast.children = [{
                type: 'tr',
                children: ast.children
            }];
        } /* React yells if things aren't in the proper structure, so need to
            delve into the immediate children and wrap the cells in a tablerow */

        if (ast.type === 'tableHeader') {
            ast.children = [{
                type: 'tr',
                children: ast.children.map(function (child) {
                    if (child.type === 'tableCell') {
                        child.type = 'th';
                    } /* et voila, a proper table header */

                    return child;
                })
            }];
        } /* React yells if things aren't in the proper structure, so need to
            delve into the immediate children and wrap the cells in a tablerow */

        if (ast.type === 'footnoteReference') {
            ast.children = [{ type: 'sup', value: ast.identifier }];
        } /* place the identifier inside a superscript tag for the link */

        var htmlNodeType = getHTMLNodeTypeFromASTNodeType(ast);
        if (htmlNodeType === null) {
            return null;
        } /* bail out, not convertable to any HTML representation */

        var props = { key: key };

        var override = overrides[htmlNodeType];
        if (override) {
            if (override.component) {
                htmlNodeType = override.component;
            } /* sub out the normal html tag name for the JSX / ReactFactory
                 passed in by the caller */

            if (override.props) {
                props = _extends({}, override.props, props);
            } /* apply the prop overrides beneath the minimal set that are necessary
                 to have the markdown conversion work as expected */
        }

        /* their props + our props, with any duplicate keys overwritten by us
           (necessary evil, file an issue if something comes up that needs
           extra attention, only props specified in `formExtraPropsForHTMLNodeType`
           will be overwritten on a key collision) */
        var finalProps = formExtraPropsForHTMLNodeType(props, ast);

        if (ast.children && ast.children.length === 1) {
            if (textTypes.indexOf(ast.children[0].type) !== -1) {
                ast.children = ast.children[0].value;
            }
        } /* solitary text children don't need full parsing or React will add a wrapper */

        var children = Array.isArray(ast.children) ? ast.children.map(astToJSX) : ast.children;

        return _react2.default.createElement(htmlNodeType, finalProps, ast.value || children);
    }

    function extractDefinitionsFromASTTree(ast) {
        var reducer = function reducer(aggregator, node) {
            if (node.type === 'definition' || node.type === 'footnoteDefinition') {
                aggregator.definitions[node.identifier] = node;

                if (node.type === 'footnoteDefinition') {
                    if (node.children && node.children.length === 1 && node.children[0].type === 'paragraph') {
                        node.children[0].children.unshift({
                            type: 'textNode',
                            value: '[' + node.identifier + ']: '
                        });
                    } /* package the prefix inside the first child */

                    aggregator.footnotes.push(_react2.default.createElement(
                        'div',
                        { key: node.identifier, id: node.identifier },
                        node.value || node.children.map(astToJSX)
                    ));
                }
            }

            return Array.isArray(node.children) ? node.children.reduce(reducer, aggregator) : aggregator;
        };

        return [ast].reduce(reducer, {
            definitions: {},
            footnotes: []
        });
    }

    if (typeof markdown !== 'string') {
        throw new Error('markdown-to-jsx: the first argument must be\n                         a string');
    }

    if (getType.call(options) !== '[object Object]') {
        throw new Error('markdown-to-jsx: the second argument must be\n                         undefined or an object literal ({}) containing\n                         valid remark options');
    }

    if (getType.call(overrides) !== '[object Object]') {
        throw new Error('markdown-to-jsx: the third argument must be\n                         undefined or an object literal with shape:\n                         {\n                            htmltagname: {\n                                component: string|ReactComponent(optional),\n                                props: object(optional)\n                            }\n                         }');
    }

    options.position = options.position || false;
    options.footnotes = options.footnotes || true;

    var remarkAST = (0, _unified2.default)().use(_remarkParse2.default).parse(markdown, options);
    var extracted = extractDefinitionsFromASTTree(remarkAST);

    definitions = extracted.definitions;
    footnotes = extracted.footnotes;

    var jsx = astToJSX(remarkAST);

    // discard the root <div> node if there is only one valid initial child
    // generally this is a paragraph
    if (jsx.props.children.length === 1) {
        jsx = jsx.props.children[0];
    }

    if (footnotes.length) {
        jsx.props.children.push(_react2.default.createElement(
            'footer',
            { key: 'footnotes' },
            footnotes
        ));
    }

    return jsx;
}
